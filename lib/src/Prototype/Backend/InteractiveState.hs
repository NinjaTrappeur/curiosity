{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE PolyKinds         #-}
{-# LANGUAGE TypeFamilies      #-}
{-# LANGUAGE DataKinds         #-}
{- |
Module: Prototype.Backend.InteractiveState
Description: Live state server
-}
module Prototype.Backend.InteractiveState
  (
    -- * Main typeclasses 
    KnownInteractiveDisp(..)
  , InteractiveState(..)
  , InteractiveStateOnDisp(..)
  -- * Supported display types. 
  , DispType(..)
  ) where

import "this"    Prelude
import qualified Text.Pretty.Simple            as Pretty

-- | The "Repl" output medium for the live state. 
data DispType = Repl

-- | A typeclass indicating how an interactive state's DispType handles the common display operations,
-- and the types of values it provides as inputs and outputs. 
class KnownInteractiveDisp (dispType :: DispType) where

  -- | The data type of input the given state-type has. 
  data StateInput (dispType :: DispType) :: Type

  -- | The data type of output the given state-type has. 
  data StateOutput (dispType :: DispType) :: Type

-- | The instance for @Repl@ is straightforward. The inputs are Text and the outputs either @Text@ or @LText@. 
instance KnownInteractiveDisp 'Repl where
  
  data StateInput 'Repl = ReplInput { replInput :: Text }
                        deriving Show
  
  data StateOutput 'Repl = ReplOutputStrict Text
                         | ReplOutputLazy LText
                         deriving Show

-- | A sum-type that encodes any operation on an interactive state. 
data AnyStateOperation state =
  AnyStateVisualisation (StateVisualisation state)
  | AnyStateModification (StateModification state)

{- |

= Synopsis:

The live state of the backend offers a way to visualise and alter the "state" of the application. By "state" here, we refer to the
storage state. This lets the /executor/ of the service, modify & visualise the stored values on the fly, irrespective of the UI.

This greatly aids in the process of rapid prototyping where the executing party doesn't need to fiddle around with the UI. 

= Note:

In the future, we'd also like to support additional modes like a @Brick@ etc., if needed. 

= Goals:

A InteractiveState should enable the user to perform the following operations on the state.

1. Query the state.

2. Modify the state, without having to restart the application

3. Generate state snapshots, optionally saving them. 

4. Revert the state to a saved snapshot. 
-}
class InteractiveState state where

  -- | Operations to modify state, represented as an ADT. 
  data StateModification state :: Type

  -- | The result of modifying the state. 
  data StateModificationResult state :: Type

  -- | Operations to visualise state, represented as an ADT. 
  data StateVisualisation state :: Type

  -- | The result of visualising the state. 
  data StateVisualisationResult state :: Type

  -- | Associated errors that can be generated by the state. 
  data InteractiveStateErr state :: Type

  -- | Constraints needed to be satisfied in which state modifications can take place. 
  type StateModificationC state :: (Type -> Type) -> Constraint

  -- | Constraints needed to be satisfied in which state visualisations can take place. 
  type StateVisualisationC state :: (Type -> Type) -> Constraint

  -- | Execute a modification.
  execModification
    :: (StateModificationC state m)
    => StateModification state
    -> m (StateModificationResult state)

  -- | Execute a visualisation. 
  execVisualisation
    :: (StateVisualisationC state m)
    => StateModification state
    -> m (StateVisualisationResult state)

-- | Given we have an instance of `InteractiveState` and a @dispType@, which is a known instance of `KnownInteractiveDisp`,
-- this typeclass encodes how operations are parsed outputs are displayed on the given `DispType`
class ( KnownInteractiveDisp dispType
      , InteractiveState state
      ) => InteractiveStateOnDisp state (dispType :: DispType) where

  -- | Constraints needed to be able to parse state inputs. 
  type StateParseInputC state dispType :: (Type -> Type) -> Constraint

  parseAnyStateOperation
    :: ( StateParseInputC state dispType m
       )
    => StateInput dispType
    -> m ( Either (InteractiveStateErr state)
                  (AnyStateOperation state)
         )
  default parseAnyStateOperation
    :: ( StateParseInputC state dispType m
       , Applicative m
       )
    => StateInput dispType
    -> m ( Either (InteractiveStateErr state)
                  (AnyStateOperation state)
         )
  parseAnyStateOperation input = (<>) <$> parseModInput <*> parseVisInput
    where
      parseModInput = second AnyStateModification <$> parseModificationInput input
      parseVisInput = second AnyStateVisualisation <$> parseVisualisationInput input

  -- | Parse the state modification input in an environment @m@ such that all parsing constraints are satsified. 
  parseModificationInput
    :: ( StateParseInputC state dispType m )
    => StateInput dispType -- ^ Raw input 
    -> m ( Either (InteractiveStateErr state)
                  (StateModification state)
         ) -- ^ We eventually return a successfully parsed modification.

  -- | Parse the state visualisation input in an environment @m@ such that all parsing constraints are satsified. 
  parseVisualisationInput
    :: ( StateParseInputC state dispType m )
    => StateInput dispType -- ^ Raw input 
    -> m ( Either (InteractiveStateErr state)
                  (StateVisualisation state)
         ) -- ^ We eventually return a successfully parsed visualisation.

    {- | Map a modification result to the output.

   The default implementation outputs as pretty text, should the modification result be an instance of `Show`. 
  -}
  displayModificationResult :: StateModificationResult state -> StateOutput dispType
  default displayModificationResult
    :: (dispType ~ 'Repl, Show (StateModificationResult state))
    => StateModificationResult state
    -> StateOutput dispType
  displayModificationResult = ReplOutputLazy . Pretty.pShow

  {- | Map a visualisation result to the output.

   The default implementation outputs as pretty text, should the visualisation result be an instance of `Show`. 
  -}
  displayVisualisationResult :: StateVisualisationResult state -> StateOutput dispType
  default displayVisualisationResult
    :: (dispType ~ 'Repl, Show (StateVisualisationResult state))
    => StateVisualisationResult state
    -> StateOutput dispType
  displayVisualisationResult = ReplOutputLazy . Pretty.pShow

