{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE PolyKinds      #-}
{-# LANGUAGE TypeFamilies   #-}
{-# LANGUAGE DataKinds      #-}
{- |
Module: Prototype.Backend.InteractiveState
Description: Live state server
-}
module Prototype.Backend.InteractiveState
  () where

import "this"    Prelude
import "start-servant" Prototype.Runtime.Storage
import qualified Text.Pretty.Simple            as Pretty

-- | The "Repl" output medium for the live state. 
data DispType = Repl

{- |

= Synopsis:

The live state of the backend offers a way to visualise and alter the "state" of the application. By "state" here, we refer to the
storage state. This lets the /executor/ of the service, modify & visualise the stored values on the fly, irrespective of the UI.

This greatly aids in the process of rapid prototyping where the executing party doesn't need to fiddle around with the UI. 

= Note:

In the future, we'd also like to support additional modes like a @Brick@ etc., if needed. 

= Goals:

A InteractiveState should enable the user to perform the following operations on the state.

1. Query the state.

2. Modify the state, without having to restart the application

3. Generate state snapshots, optionally saving them. 

4. Revert the state to a saved snapshot. 
-}
class InteractiveState state (dispType :: DispType) where

  -- | Operations to modify state, represented as an ADT. 
  data StateModification state :: Type

  -- | The result of modifying the state. 
  data StateModificationResult state dispType :: Type

  -- | Operations to visualise state, represented as an ADT. 
  data StateVisualisation state :: Type

  -- | The result of visualising the state. 
  data StateVisualisationResult state dispType :: Type

  -- | Associated errors that can be generated by the state. 
  data InteractiveStateErr state :: Type

  -- | Constraints needed to be satisfied in which state modifications can take place. 
  type StateModificationC state dispType :: (Type -> Type) -> Constraint

  -- | Constraints needed to be satisfied in which state visualisations can take place. 
  type StateVisualisationC state dispType :: (Type -> Type) -> Constraint

  -- | Constraints needed to be able to parse state inputs. 
  type StateParseInputC state dispType :: (Type -> Type) -> Constraint

  -- | Parse the state modification input in an environment @m@ such that all parsing constraints are satsified. 
  parseModificationInput
    :: ( StateParseInputC state dispType m )
    => StateInput dispType -- ^ Raw input 
    -> m ( Either (InteractiveStateErr state)
                  (StateModification state)
         ) -- ^ We eventually return a successfully parsed modification.

  -- | Parse the state visualisation input in an environment @m@ such that all parsing constraints are satsified. 
  parseVisualisationInput
    :: ( StateParseInputC state dispType m )
    => StateInput dispType -- ^ Raw input 
    -> m ( Either (InteractiveStateErr state)
                  (StateVisualisation state)
         ) -- ^ We eventually return a successfully parsed visualisation.

  -- | Execute a modification.
  execModification
    :: ( StateModificationC state dispType m )
    => StateModification state
    -> m (StateModificationResult state dispType)

  -- | Execute a visualisation. 
  execVisualisation
    :: ( StateVisualisationC state dispType m )
    => StateModification state
    -> m (StateVisualisationResult state dispType)

  {- | Map a modification result to the output.

   The default implementation outputs as pretty text, should the modification result be an instance of `Show`. 
  -}
  displayModificationResult :: StateModificationResult state dispType -> StateOutput dispType
  default displayModificationResult
    :: (dispType ~ 'Repl, Show (StateModificationResult state dispType))
    => StateModificationResult state dispType
    -> StateOutput dispType
  displayModificationResult = ReplOutputLazy . Pretty.pShow

  {- | Map a visualisation result to the output.

   The default implementation outputs as pretty text, should the visualisation result be an instance of `Show`. 
  -}
  displayVisualisationResult :: StateVisualisationResult state dispType -> StateOutput dispType
  default displayVisualisationResult
    :: (dispType ~ 'Repl, Show (StateVisualisationResult state dispType))
    => StateVisualisationResult state dispType
    -> StateOutput dispType
  displayVisualisationResult = ReplOutputLazy . Pretty.pShow


class InteractiveStateDisp (dispType :: DispType) where

  -- | The data type of input the given state-type has. 
  data StateInput (dispType :: DispType) :: Type

  -- | The data type of output the given state-type has. 
  data StateOutput (dispType :: DispType) :: Type

instance InteractiveStateDisp 'Repl where
  
  data StateInput 'Repl = ReplInput { replInput :: Text }
                        deriving Show
  
  data StateOutput 'Repl = ReplOutputStrict { replOutputStrict :: Text }
                         | ReplOutputLazy { replOutputLazy :: LText }
                         deriving Show
